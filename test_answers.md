### ВОПРОСЫ К ЗАЧЕТУ ПО ПРОГРАММИРОВАНИЮ НА 1 КУРСЕ

---

1.  **Условные переходы, команда сравнения знаковых чисел**
    -   Кроме безусловного перехода в ассемблере также есть команды. которые производят условный переход к необходимой метке
    -   Типы команд условного перехода: отножение между знаковыми, отношение между беззнаковыми, проверка состояния флагов
    -   Общая структура команды: jxx метка_перехода
    -   Источники условия для перехода: арифметические операции, результат команды CMP, состояние регистра ECX
    -   Знаковое: JE, JNE, JL, JLE, JG, JGE
    -   Беззнаковое: JE, JNE, JB(<), JBE, JA, JAE
    -   ECX, CX: JCXZ, JECXZ ( == 0)
2.  **Условные переходы, команда сравнения беззнаковых знаковых чисел**
    -   Смотри **Вопрос 1**
3.  **Организация циклов: команда LOOP**
    -   Команда LOOP метка_перехода
    -   Счетчик - регистры ECX/CX (2^32/65536 повторений максимально)
    -   Цикл с постусловием - выполнится хотя бы один раз (если в ECX - 0, то 2^32 повторений)
    -   Значение регистров ECX/CX рассматриваются как беззнаковое целое
4.  **Модификации команды LOOPx**
    -   LOOPE, LOOPZ - идентичные по действию команды:
        -   ((ЕСХ/СХ) > 0 && ZF == 1) - переход на метку
        -   ((ЕСХ/СХ) == 0 || ZF == 0) - переход к следущей после цикла команде
    -   LOOPNE, LOOPNZ - идентичные команды:
        -   ((ЕСХ/СХ) > 0 && ZF == 0) - переход на метку
        -   ((ЕСХ/СХ) == 0 || ZF == 1) - переход к следущей после цикла команде
    -   Используются для досрочного выхода из цикла, путем изменения флага ZF.
5.  **Использование процедур на ассемблере в С++**
    -   Процедура(подпрограмма) - минимаьлная композиционная единица решения задачи
    -   Начало процедуры - proc
    -   Конец процедуры - endp
    -   Объявление с помощью PUBLIC.
    -   Объявление в коде C++: _extern “C” тип*возврата тип*соглашения имя (параметры);_
    -   Соглашения вызова:
        -   \_\_fastcall - ecx, edx (слева направо). Очистка стека - вызывающая программа
        -   \_\_stdcall - стек (справо налево). Очистка стека - процедура
        -   \_\_cdecl - стек (справо налево). Очистка стека - вызывающая программа.
    -   Воазврат: возвращаемое значение заносится в EAX и вызывается команда RET
6.  **Команды CALL, RET**
    -   Команды для работы с контекстом
    -   CALL - вызов процедуры. Алгоритм работы: закидывает в стек адрес следующей после CALL команды, осуществляет переход к нужной метке. **call \[модификатор\] имя_процедуры**
    -   RET - Алгоритм работы: достает из стека адрес команды, которая следует после вызова процедуры, и осуществляет переход на нее. **ret \[число\]**, где число - необязательный параметр, который определяет количество удаляемых из стека элементов.
    -   Команды не изменяют флаги

_Общая часть для следущих 4-х вопросов:_

-   Соглашения вызова (Calling convention) определяют, как происходит вызов подпрограммы, передаются аргументы, осуществляется возврат из подпрограммы и возвращается результат.
-   Соглашения вызова:
    -   \_\_fastcall - ecx, edx (слева направо). Очистка стека - вызывающая программа
    -   \_\_stdcall - стек (справо налево). Очистка стека - процедура
    -   \_\_cdecl - стек (справо налево). Очистка стека - вызывающая программа.

7.  **Соглашения об интерфейсе. Декорирование имен в трансляторе C++.**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Декорированное имя (украшенное имя) - имя функции, созданное компилятором на этапе компиляции. Оно содержит соглашение вызова, типы параметров, имя функции, пространство имен и т.д.

8.  **Соглашения об интерфейсе. Возврат результата**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Фрагмент процедуры, ответственный за корректный возврат - **эпилог**.
    -   После работы основной части процедуры, вызванной ЧЕРЕЗ СТЕК, должна быть произведена очистка стека. Есть 2 варианта:
        -   очистку производит процедура. Пример: ret \[число очищаемых байт\]
        -   очистку производит вызывающий код. После вызова CALL происходит извлечение переданных аргументов из стека

9.  **Соглашения об интерфейсе.Передача параметров через регистры**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Передача параметров через регистры - наиболее простой способ.
    -   Когда использовать - когда небольшое количество парметров
    -   Недостатки:
        -   ограничения по количеству параметров
        -   нужно постоянно помнить в каком регистре что лежит
        -   есть ограничение размера передаваемых данных размерами регистра - 32 бита.

10. **Соглашения об интерфейсе.Передача параметров через стек**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Передача параметров через стек - наиболее популярный способ
    -   Суть: вызывающий код самостоятельно заносит в стек все аргументы
    -   4 первых байта стека - адрес следующей после CALL команды
    -   ESS - указатель на начало сегмента стека, ESP - указатель на вершину стека, EBP - указатель базы (нужен для осуществления произвольного доступа к данным в стеке).
    -   ````asm
        push ebp ; чтобы исключить порчу находящегося в нем значения в вызываемой процедуре
        mov ebp, esp ; настраивает ebp на вершину стека
        ``` - пролог
        ````

11. **Директивы PUBLIC, EXTERN**

    -   Модуль - автономная часть программы. Модуль ничего не знает о других модулях и их внутреннем устройстве.
    -   PUBLIC - директива, которая говорит, что данный компонент модуля виден для других по модулей и может быть ими использован.
    -   EXTERN - директива, указывающая, что необходимый компонент нужно искать во внешних модулях.
    -   Использование: **extern имя: тип имя: тип; public имя, ..., имя**. Где **имя** - имя переменной, процедуры, константы; **тип** - соответсвенно (BYTE, DWORD...), (near, far), (abs)

---

12. **Объясните принципы фон-неймановской архитектуры**
    -   Использование двоичной системы счисления в вычислительных машинах.
    -   Линейное пространство памяти.
    -   Принцип микропрограммирования. (Машинный язык не конечный. Процессор содержит инструкции по генерации физических сигналов)
    -   Последовательное выполнение программ.
    -   Отсутствие разницы между данными и командами в памяти.
    -   Безразличие к назначению данных. (Машине все равно на логику - она просто выполняет команды. Можно легко переносить программы)
13. **Объясните критерии выбора двоичной системы счисления**
    -   Удобство использования - проще закодировать и изготовить устройства оперирующие всего двумя возможными значениями
    -   Помехоустойчивость и скорость
    -   Легкое использование арифметического и логического аппарата
    -   **МИНУС** - для перевода из 10сс в 2сс требуется время
14. **Схема формирования адреса в реальном режиме**
    -   Процессор использует сегментные регистры, чтобы определить базовый адрес сегмента из которого что-то нужно взять.
    -   Смещение - смещение на которое нужно сдвинуться относительно базового адреса сегмента, чтобы прийти к запрашиваемым данным.
    -   Базовый адрес сегмента и смещение складываются - получается физический адрес, запрашиваемых данных.
15. **Структура регистра флагов: краткая характеристика использования флагов**
    -   Разрядность - 32(16) битов
    -   Нужны для отображения особенностей выполнения некоторых команд
    -   Можно разделить на 3 группы
        -   8 флагов состояния - особенности выполнения арифметических операций
        -   1 флаг группы управления - для работы со строками
        -   8 системных флагов - отладка, ввод-вывод и т.д.
16. **Стандартные директивы сегментации (перечислить и указать назначение)**
    -   SEGMENT - объявление нового сегмента
    -   ENDS - конец сегмента
    -   ASSUME - привязка сегмента к конкретному регистру
    -   ORG - задает абсолютное смещение, начиная с которого будет производится внутрення адресация. ORG 100H - 4113 байт. Это пространство нужно для размещения всякой дополнительной информации - управляющих структур и т.д.
17. **Упрощенные директивы сегментации**
18. **Упрощенные директивы сегментации: значения по умолчанию**
19. **Директивы описания данных**
20. **Использование операторов PTR, OFFSET**
    -   PTR - оператор необходимый для переопределения типа
    -   PTR - оператор взятия адреса некоторого объекта
    -   OFFSET - оператор получения смещения объекта

---

21. **Какие типы данных обрабатывает сопроцессор.**

    -   Сопроцессор - под ним понимается сопроцессор числовых вычислений, необходимый для произведения операций над вещественными числами (FPU - Floating Point Unit).
    -   Сопроцессор работает со следущими типами:
        -   двоичное целое
        -   упакованное десятичное целое
        -   вещественные числа (float-32, double-64, расширенный-80)
    -   Также происходит обработка специфичных численных значений:
        -   нуль
        -   +- бесконечность
        -   нечисла
        -   неопределенности
        -   денормализованные числа

22. **Форматы вещественных чисел. Различия в представлении вещественных данных**
    -   FLOAT
        -   32 бита - 1 знаковый бит, 8 бит экспоненты, 23 бита мантиссы
    -   DOUBLE
        -   64 бита - 1 знаковый бит, 11 бит экспоненты, 52 бита мантиссы
    -   РАСШИРЕННЫЙ
        -   80 бит - 1 знаковый бит, 16 бит экспоненты, 63 бита мантиссы
23. **Специальные числа и нечисла**
    -   Существуют специальные числа для отображения специфичных значений
    -   Ноль (FLDZ - закинуть ноль в стек)
    -   Бесконечность (Infinity)
    -   NaN (Not a number) - спец. значение, которое представляет результат некорректной операции (деление на нуль например). Для сопроцессора - FLDNaN.
        -   Есть 2 типа NaN чисел - сигнальные (появление которых приводит к созданию исключения) и спокойные (появление их в результате выполнения программы не приводит к выбросу исключения)
    -   Денормализованные числа - числа с маленькой точностью
24. **Слово управления сопроцессора: назначение групп битов и отдельных битов**
    -   Регистр управления сопроцессором. Необходим для уточнения желаемого поведения программы. Например установка точности вычислений, маскировка исключений и т.д.
        -   маскировка исключений - установка соответствующих флагов будет говорить о том - обрабатывать ли исключение самому сопроцессору, или генерировать прерывание, которое будет обработано ОС/программистом
        -   поля управления точностью
        -   поля управления округлением
25. **Слово состояния сопроцессора: назначение групп битов и отдельных битов**
    -   Регистр состояния сопроцессора. Содержит следущую информацию:
        -   какой регистр является текущей вершиной стека
        -   информация об исключительных ситуациях
        -   особенности выполнения предыдущей команды (аналог регистра флагов)
26. **Стек сопроцессора и его использование**
    -   Вершина стека является плавающей и вычисляется аппаратно. В поле TOP лежит номер регистра (R0...R7) в котором сейчас находится вершина.
    -   Различают логические номера и физические номера. Логические - ST(0), ST(1)... Физические - R0...R7. причем стек на физических регистрах идет в сторону убывания номеров - первый элемент на R7,...
    -   Стек организован по принципу кольца, т.е. после добавления значения в R0, следущее будет закинуто в R7.
27. **Анализ результата работы команды сопроцессора**
    -   Для сравнения вещественных чисел есть специальный набор комманд (FCOM, FCOMP и т.д.)
    -   Если один из операторов нечисло, то будет сгенерирована исключительная ситуация
    -   Чтобы сравнивать нечисла есть спец. команды (FUCOM...) которые рассматривают их как вещественные числа
28. **Команды загрузки и выгрузки сопроцессора**
29. **Арифметические команды. Нуль, один, два операнда арифметических команд**
30. **Вычисление значений тригонометрических функций**
31. **Вычисление значений логарифмических функций**
32. **Вычисление значений трансцедентных функций**
33. **Программные прерывания. Действия по обработке программного прерывания**
34. **Команды INT, IRET**
35. **Источники и виды прерываний**
    -   Прерывание - событие в результате которого программа прерывается и переходит к выполнению специального кода - обработчика прерывания
    -   Виды прерываний: внешние (появление сигнала на входе), внутренние (деление на нуль), программные (вызваны спец. командами)
36. **Аппаратные средства 64-разрядных приложений**
37. **Передача параметров для 64-разрядных приложений**
38. **Теневая область: для чего используется**

### ДОПОЛНИТЕЛЬНЫЕ УТОЧНЯЮЩИЕ ВОПРОСЫ

1. **Сегмент стека: регистры для работы со стеком, адресация**
    - Нужен для того, чтобы сохранить некоторые данные в ходе выполнения программы
    - Адрес храниться в регистре SS. Если нужно использовать другой стек - нужно поместить адрес второго стека в регистр SS.
    - Особенности работы:
        - ESP хранит указатель на вершину стека. Значение ESP рассматривается как смещение относительно адреса стека
        - Растет к меньшим адресам
        - работает по принципу LIFO
2. **Команды работы со стеком (запись, выборка)**
    - PUSH источник - добавление элемента на вершину стека. ESP уменьшается на размер источника
    - POP приемник - извлечение элемента с вершины стека. ESP увеличивается на размер премника
    - PUSHA - закидывает все из регистров общего назначения
    - POPA - вычитывает из стека в регистры общего назначения
    - PUSHF/POPF - тоже самое только с регистром флагов
3. **Операции умножения**
    - mul, imul
    - Формы: (i)mul source (eax \*= src); (i)mul destination, source (dest \*= src); (i)mul destination, source, constant (dest = src \* cnt);
4. **Операция деления**
    - div, idiv
    - Формы: (i)div source (eax /= src)
    - Перед вызовом idiv нужно расширить регистр с помощью команды cdq (есть и другие, но это наиболее часто используемая), она расширяет EAX до EAX:EDX
5. **Команды расширения занимаемой памяти. Для чего они нужны?**
6. Формирование адреса в защищенном режиме
7. Селекторы: назначение, структура
8. Структура дескриптора GDT-таблицы.
9. Структура байтов атрибутов
10. Селекторы: назначение, структура
11. Как передать подпрограмме адрес?
12. Где могут находиться операнды, используемые в командах ассемблера?
13. Возможно ли переполнение при умножении?
14. Исключения для команды целочисленного деления
15. Как проверить значение отдельных битов/группы битов?
16. Почему переходы по результатам сравнения целых чисел выполняется различными командами для наковых и беззнаковых чисел?
17. Можно ли перейти на метку, расположенную выше/ниже команды перехода? На саму команду перехода?
18. Что произойдет, если количество итераций для LOOP равно 0?
19. Можно ли выйти из цикла командой перехода? Можно ли войти в тело цикла командой перехода? 20. На какие логические единицы разбивается исходная программа?
20. Какие умолчания используются в упрощенных директивах?
21. Какие команды учитывают тип вызова?
22. Как вернуть несколько значений из процедуры?
23. В каком порядке размещаются параметры процедуры в стеке?
24. Кто должен очистить стек по окончанию процедуры?
25. Какая последовательность команд может заменить команду call?
26. Какая последовательность команд может заменить команду ret?
27. Назначение описателя extern “C”?
28. Как объявить внешнюю процедуру?
29. Использование регистра EBP для доступа к параметрам стека?
30. Где могут находиться операнды машинных команд?
31. Как обрабатывать в команде операнды разной длины?
32. Как процессор определяет знак операнда?
33. Как определить количество единичных/нулевых битов поля с помощью сдвигов?
34. Почему переход по результатам сравнения знаковых и беззнаковых чисел выполняется разными командами?
35. Можно ли войти в тело цикла командой перехода?
36. Как получить доступ к очередному элементу массива, используя различные способы адресации?
37. Как определить массив в директивах распределения памяти?
38. Почему для модели FLAT нет необходимости использовать директиву ASSUME?
39. Сколько параметров можно передать через стек? через регистры?
40. Как процедуре передать массив?
41. Какие регистры используются для работы со стеком? 43. Верны ли следующие утверждения:

    - селектор определяет элемент таблицы дескрипторов;
      -селектор является 32-битовым регистром;
    - в дескрипторе указывается длина сегмента.

42. В каких единицах указан размер сегмента в дескрипторе?
