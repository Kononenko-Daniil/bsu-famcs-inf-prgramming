### ВОПРОСЫ К ЗАЧЕТУ ПО ПРОГРАММИРОВАНИЮ НА 1 КУРСЕ

---

1.  **Условные переходы, команда сравнения знаковых чисел**
    -   Кроме безусловного перехода в ассемблере также есть команды. которые производят условный переход к необходимой метке
    -   Типы команд условного перехода: отножение между знаковыми, отношение между беззнаковыми, проверка состояния флагов
    -   Общая структура команды: jxx метка_перехода
    -   Источники условия для перехода: арифметические операции, результат команды CMP, состояние регистра ECX
    -   Знаковое: JE, JNE, JL, JLE, JG, JGE
    -   Беззнаковое: JE, JNE, JB(<), JBE, JA, JAE
    -   ECX, CX: JCXZ, JECXZ ( == 0)
2.  **Условные переходы, команда сравнения беззнаковых знаковых чисел**
    -   Смотри **Вопрос 1**
3.  **Организация циклов: команда LOOP**
    -   Команда LOOP метка_перехода
    -   Счетчик - регистры ECX/CX (2^32/65536 повторений максимально)
    -   Цикл с постусловием - выполнится хотя бы один раз (если в ECX - 0, то 2^32 повторений)
    -   Значение регистров ECX/CX рассматриваются как беззнаковое целое
4.  **Модификации команды LOOPx**
    -   LOOPE, LOOPZ - идентичные по действию команды:
        -   ((ЕСХ/СХ) > 0 && ZF == 1) - переход на метку
        -   ((ЕСХ/СХ) == 0 || ZF == 0) - переход к следущей после цикла команде
    -   LOOPNE, LOOPNZ - идентичные команды:
        -   ((ЕСХ/СХ) > 0 && ZF == 0) - переход на метку
        -   ((ЕСХ/СХ) == 0 || ZF == 1) - переход к следущей после цикла команде
    -   Используются для досрочного выхода из цикла, путем изменения флага ZF.
5.  **Использование процедур на ассемблере в С++**
    -   Процедура(подпрограмма) - минимаьлная композиционная единица решения задачи
    -   Начало процедуры - proc
    -   Конец процедуры - endp
    -   Объявление с помощью PUBLIC.
    -   Объявление в коде C++: _extern “C” тип*возврата тип*соглашения имя (параметры);_
    -   Соглашения вызова:
        -   \_\_fastcall - ecx, edx (слева направо). Очистка стека - вызывающая программа
        -   \_\_stdcall - стек (справо налево). Очистка стека - процедура
        -   \_\_cdecl - стек (справо налево). Очистка стека - вызывающая программа.
    -   Воазврат: возвращаемое значение заносится в EAX и вызывается команда RET
6.  **Команды CALL, RET**
    -   Команды для работы с контекстом
    -   CALL - вызов процедуры. Алгоритм работы: закидывает в стек адрес следующей после CALL команды, осуществляет переход к нужной метке. **call \[модификатор\] имя_процедуры**
    -   RET - Алгоритм работы: достает из стека адрес команды, которая следует после вызова процедуры, и осуществляет переход на нее. **ret \[число\]**, где число - необязательный параметр, который определяет количество удаляемых из стека элементов.
    -   Команды не изменяют флаги

_Общая часть для следущих 4-х вопросов:_

-   Соглашения вызова (Calling convention) определяют, как происходит вызов подпрограммы, передаются аргументы, осуществляется возврат из подпрограммы и возвращается результат.
-   Соглашения вызова:
    -   \_\_fastcall - ecx, edx (слева направо). Очистка стека - вызывающая программа
    -   \_\_stdcall - стек (справо налево). Очистка стека - процедура
    -   \_\_cdecl - стек (справо налево). Очистка стека - вызывающая программа.

7.  **Соглашения об интерфейсе. Декорирование имен в трансляторе C++.**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Декорированное имя (украшенное имя) - имя функции, созданное компилятором на этапе компиляции. Оно содержит соглашение вызова, типы параметров, имя функции, пространство имен и т.д.

8.  **Соглашения об интерфейсе. Возврат результата**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Фрагмент процедуры, ответственный за корректный возврат - **эпилог**.
    -   После работы основной части процедуры, вызванной ЧЕРЕЗ СТЕК, должна быть произведена очистка стека. Есть 2 варианта:
        -   очистку производит процедура. Пример: ret \[число очищаемых байт\]
        -   очистку производит вызывающий код. После вызова CALL происходит извлечение переданных аргументов из стека

9.  **Соглашения об интерфейсе.Передача параметров через регистры**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Передача параметров через регистры - наиболее простой способ.
    -   Когда использовать - когда небольшое количество парметров
    -   Недостатки:
        -   ограничения по количеству параметров
        -   нужно постоянно помнить в каком регистре что лежит
        -   есть ограничение размера передаваемых данных размерами регистра - 32 бита.

10. **Соглашения об интерфейсе.Передача параметров через стек**

    -   _ОБЩАЯ ЧАСТЬ_
    -   Передача параметров через стек - наиболее популярный способ
    -   Суть: вызывающий код самостоятельно заносит в стек все аргументы
    -   4 первых байта стека - адрес следующей после CALL команды
    -   ESS - указатель на начало сегмента стека, ESP - указатель на вершину стека, EBP - указатель базы (нужен для осуществления произвольного доступа к данным в стеке).
    -   ````asm
        push ebp ; чтобы исключить порчу находящегося в нем значения в вызываемой процедуре
        mov ebp, esp ; настраивает ebp на вершину стека
        ``` - пролог
        ````

11. **Директивы PUBLIC, EXTERN**

    -   Модуль - автономная часть программы. Модуль ничего не знает о других модулях и их внутреннем устройстве.
    -   PUBLIC - директива, которая говорит, что данный компонент модуля виден для других по модулей и может быть ими использован.
    -   EXTERN - директива, указывающая, что необходимый компонент нужно искать во внешних модулях.
    -   Использование: **extern имя: тип имя: тип; public имя, ..., имя**. Где **имя** - имя переменной, процедуры, константы; **тип** - соответсвенно (BYTE, DWORD...), (near, far), (abs)

---

12. Объясните принципы фон-неймановской архитектуры
13. Объясните критерии выбора двоичной системы счисления
14. Схема формирования адреса в реальном режиме
15. Структура регистра флагов: краткая характеристика использования флагов
16. Стандартные директивы сегментации (перечислить и указать назначение)
17. Упрощенные директивы сегментации
18. Упрощенные директивы сегментации: значения по умолчанию
19. Директивы описания данных
20. Использование оператора PTR

21. Организация циклов: команда LOOP
22. Модификации команды LOOPx
23. Использование процедур на ассемблере в С++.
24. Команды CALL, RET
25. Соглашения об интерфейсе. Декорирование имен в трансляторе C++.
26. Соглашения об интерфейсе.. Возврат результата
27. Передача параметров через регистры
28. Передача параметров через стек
29. Директивы PUBLIC, EXTRN
30. Какие типы данных обрабатывает сопроцессор.
31. Форматы вещественных чисел. Различия в представлении вещественных данных
32. Специальные числа и нечисла
33. Слово управления сопроцессора
34. Слово состояния сопроцессора
35. Анализ результата работы команды сопроцессора
36. Команды загрузки и выгрузки сопроцессора
37. Арифметические команды. Нуль, один, два операнда арифметических команд
38. Программные прерывания. Действия по обработке программного прерывания
39. Команды INT, IRET
40. Источники и виды прерываний

41. Аппаратные средства 64-разрядных приложений
42. Передача параметров для 64-разрядных приложений
43. Теневая область: для чего используется

ДОПОЛНИТЕЛЬНЫЕ УТОЧНЯЮЩИЕ ВОПРОСЫ

1. Сегмент стека: регистры для работы со стеком, адресация
2. Команды работы со стеком (запись, выборка)
3. Операции умножения
4. Операция деления
5. Команды расширения занимаемой памяти. Для чего они нужны?
6. Формирование адреса в защищенном режиме
7. Селекторы: назначение, структура
8. Структура дескриптора GDT-таблицы.
9. Структура байтов атрибутов
10. Селекторы: назначение, структура
11. Как передать подпрограмме адрес?
12. Где могут находиться операнды, используемые в командах ассемблера?
13. Возможно ли переполнение при умножении?
14. Исключения для команды целочисленного деления
15. Как проверить значение отдельных битов/группы битов?
16. Почему переходы по результатам сравнения целых чисел выполняется различными командами для наковых и беззнаковых чисел?
17. Можно ли перейти на метку, расположенную выше/ниже команды перехода? На саму команду перехода?
18. Что произойдет, если количество итераций для LOOP равно 0?
19. Можно ли выйти из цикла командой перехода? Можно ли войти в тело цикла командой перехода? 20. На какие логические единицы разбивается исходная программа?
20. Какие умолчания используются в упрощенных директивах?
21. Какие команды учитывают тип вызова?
22. Как вернуть несколько значений из процедуры?
23. В каком порядке размещаются параметры процедуры в стеке?
24. Кто должен очистить стек по окончанию процедуры?
25. Какая последовательность команд может заменить команду call?
26. Какая последовательность команд может заменить команду ret?
27. Назначение описателя extern “C”?
28. Как объявить внешнюю процедуру?
29. Использование регистра EBP для доступа к параметрам стека?
30. Где могут находиться операнды машинных команд?
31. Как обрабатывать в команде операнды разной длины?
32. Как процессор определяет знак операнда?
33. Как определить количество единичных/нулевых битов поля с помощью сдвигов?
34. Почему переход по результатам сравнения знаковых и беззнаковых чисел выполняется разными командами?
35. Можно ли войти в тело цикла командой перехода?
36. Как получить доступ к очередному элементу массива, используя различные способы адресации?
37. Как определить массив в директивах распределения памяти?
38. Почему для модели FLAT нет необходимости использовать директиву ASSUME?
39. Сколько параметров можно передать через стек? через регистры?
40. Как процедуре передать массив?
41. Какие регистры используются для работы со стеком? 43. Верны ли следующие утверждения:

    - селектор определяет элемент таблицы дескрипторов;
      -селектор является 32-битовым регистром;
    - в дескрипторе указывается длина сегмента.

42. В каких единицах указан размер сегмента в дескрипторе?
