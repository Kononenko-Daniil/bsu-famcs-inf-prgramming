<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0210)file:///D:/bsu/studying/programming/bsu-famcs-inf-programming/helpers/string/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20C++%20(%D0%BA%D0%BB%D0%B0%D1%81%D1%81%20string).html -->
<html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="./string_files/MathJax.js.Без названия"></script><script src="./string_files/tex-svg.js.Без названия" async=""></script><script src="./string_files/tex-svg.js(1).Без названия" async=""></script>
<link rel="stylesheet" type="text/css" href="./string_files/style.css">

<title>Строки в языке C++ (класс string)</title><script type="module" src="chrome-extension://jdkknkkbebbapilgoeccciglkfbmbnfm/hook.js"></script>
<script src="./string_files/chtml.js.Без названия" charset="UTF-8"></script><script src="./string_files/tex.js.Без названия" charset="UTF-8"></script><style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-SVG-styles">
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}
</style><script src="file:///D:/bsu/studying/programming/bsu-famcs-inf-programming/helpers/string/%D0%A1%D1%82%D1%80%D0%BE%D0%BA%D0%B8%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20C++%20(%D0%BA%D0%BB%D0%B0%D1%81%D1%81%20string)_files/output/chtml.js" charset="UTF-8"></script></head>
<body>
<h1>Строки в языке C++ (класс string)</h1>

<h1>Основы работы со строками в C++</h1>
<p>В языке C++ для удобной работы со строками есть класс string, для использования которого необходимо подключить заголовочный файл string.</p>
<p>Строки можно объявлять и одновременно присваивать им значения:</p>
<div class="page_code_style">
<p>string S1, S2 = "Hello";</p>
</div>
<p>Строка S1 будет пустой, строка S2 будет состоять из 5 символов.</p>
<p>К отдельным символам строки можно обращаться по индексу, как к элементам массива или C-строк. Например <span class="page_code_style">S[0]</span> - это первый символ строки.</p>
<p>Для того, чтобы узнать длину строки можно использовать метод size() строки. Например, последний символ строки S это <span class="page_code_style">S[S.size() - 1</span>].</p>
<p>Строки в языке C++ могут</p>

<h2>Конструкторы строк</h2>
<p>Строки можно создавать с использованием следующих конструкторов:<br> <code>string()</code> - конструктор по умолчанию (без параметров) создает пустую строку.<br> <code>string(string &amp; S)</code> - копия строки <code>S</code><br> <code>string(</code><code><code>size_t </code>n, char c)</code> - повторение символа <code>c</code> заданное число <code>n</code> раз.<br> <code>string(size_t c)</code> - строка из одного символа <code>c</code>.<br> <code>string(string &amp; S, </code><code><code>size_t</code> start, </code><code><code>size_t </code>len)</code> - строка, содержащая не более, чем <code>len</code> символов данной строки <code>S</code>, начиная с символа номер <code>start</code>.</p>
<p>Конструкторы можно вызывать явно, например, так:</p>
<pre>&nbsp;</pre>
<div class="page_code_style">
<p>S += string(10, 'z');</p>
</div>
<p>В этом примере явно вызывается конструктор <code>string</code> для создания строки, состоящей из 10 символов <code>'z'</code>.</p>
<p>Неявно конструктор вызывается при объявлении строки с указанием дополнительных параметров. Например, так:</p>
<div class="page_code_style">
<p>string S(10, 'z');</p>
</div>
<p>Подробней о конструкторах для строк читайте <a href="http://www.cppreference.com/wiki/ru/string/string_constructors">здесь</a>.</p>
<h2>&nbsp;</h2>


<h2>Ввод-вывод строк</h2>
<p>Строка выводится точно так же, как и числовые значения:</p>
<div class="page_code_style">
<p>cout &lt;&lt; S;</p>
</div>
<p>Для считывания строки можно использовать операцию "&gt;&gt;" для объекта cin:</p>
<div class="page_code_style">
<p>cin &gt;&gt; S;</p>
</div>
<p>В этом случае считывается строка из непробельных символов, пропуская пробелы и концы строк. Это удобно для того, чтобы разбивать текст на слова, или чтобы читать данные до конца файла при помощи <span class="page_code_style">while (cin &gt;&gt; S)</span>.</p>
<p>Можно считывать строки до появления символа конца строки при помощи функции getline. Сам символ конца строки считывается из входного потока, но к строке не добавляется:</p>
<div class="page_code_style">
<p>getline(cin S);</p>
</div>


<h2>Арифметические операторы</h2>
<p>Со строками можно выполнять следующие арифметические операции:<br> <code>=</code> - присваивание значения.<br> <code>+=</code> - добавление в конец строки другой строки или символа.<br> <code>+</code> - конкатенация двух строк, конкатенация строки и символа.<br> <code>==</code>, <code>!=</code> - посимвольное сравнение.<br> <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> - лексикографическое сравнение.</p>
<p>То есть можно скопировать содержимое одной строки в другую при помощи операции S1 = S2, сравнить две строки на равенство при помощи S1 == S2, сравнить строки в лексикографическом порядке при помощи S1 &lt; S2, или сделать сложение (конкатенацию) двух строк в виде S = S1 + S2.</p>
<p>Подробней об операторах для строк читайте <a href="http://www.cppreference.com/wiki/ru/string/string_operators">здесь</a>.</p>

<h2>Методы строк</h2>
<p>У строк есть разные методы, многие из них можно использовать несколькими разными способами (с разным набором параметров).</p>
<p>Рассмотрим эти методы подробней.</p>
<h3>size</h3>
<p>Метод size() возращает длину длину строки. Возвращаемое значение является беззнаковым типом (как и во всех случаях, когда функция возращает значение, равное длине строке или индексу элемента - эти значения беззнаковые). Поэтому нужно аккуратно выполнять операцию вычитания из значения, которое возвращает size(). Например, ошибочным будет запись цикла, перебирающего все символы строки, кроме последнего, в виде for (int i = 0; i &lt; S.size() - 1; ++i).</p>
<p>Кроме того, у строк есть метод length(), который также возвращает длину строки.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:size" href="http://www.cppreference.com/wiki/ru/string/size">size</a>.</p>
<h3>resize</h3>
<p><span class="page_code_style">S.resize(n)</span> - Изменяет длину строки, новая длина строки становится равна n. При этом строка может как уменьшится, так и увеличиться. Если вызвать в виде <span class="page_code_style">S.resize(n, c)</span>, где c - символ, то при увеличении длины строки добавляемые символы будут равны c.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:resize" href="http://www.cppreference.com/wiki/ru/string/resize">resize</a>.</p>
<h3>clear</h3>
<p><span class="page_code_style">S.clear()</span> - очищает строчку, строка становится пустой.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:clear" href="http://www.cppreference.com/wiki/ru/string/clear">clear</a>.</p>
<h3>empty</h3>
<p><span class="page_code_style">S.empty()</span> - возвращает true, если строка пуста, false - если непуста.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:empty" href="http://www.cppreference.com/wiki/ru/string/empty">empty</a>.</p>
<h3>push_back</h3>
<p><span class="page_code_style">S.push_back(c)</span> - добавляет в конец строки символ c, вызывается с одним параметром типа char.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:push_back" href="http://www.cppreference.com/wiki/ru/string/push_back">push_back</a>.</p>
<h3>append</h3>
<p>Добавляет в конец строки несколько символов, другую строку или фрагмент другой строки. Имеет много способов вызова.</p>
<p><span class="page_code_style">S.append(n, c)</span> - добавляет в конец строки n одинаковых символов, равных с. n имеет целочисленный тип, c - char.</p>
<p><span class="page_code_style">S.append(T)</span> - добавляет в конец строки S содержимое строки T. T может быть объектом класса string или C-строкой.</p>
<p><span class="page_code_style">S.append(T, pos, count)</span> - добавляет в конец строки S символы строки T начиная с символа с индексом pos количеством count.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:append" href="http://www.cppreference.com/wiki/ru/string/append">append</a>.</p>
<h3>erase</h3>
<p><span class="page_code_style">S.erase(pos)</span> - удаляет из строки S&nbsp; с символа с индексом pos и до конца строки.</p>
<p><span class="page_code_style">S.erase(pos, count)</span> - удаляет из строки S&nbsp; с символа с индексом pos количеством count или до конца строки, если pos + count &gt; S.size().</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:erase" href="http://www.cppreference.com/wiki/ru/string/erase">erase</a>.</p>
<h3>insert</h3>
<p>Вставляет в середину строки несколько символов, другую строку или фрагмент другой строки. Способы вызова аналогичны способам вызова метода append, только первым параметром является значение i - позиция, в которую вставляются символы. Первый вставленный символ будет иметь индекс i, а все символы, которые ранее имели индекс i и более сдвигаются вправо.</p>
<p><span class="page_code_style">S.insert(i, n, c)</span> - вставить n одинаковых символов, равных с. n имеет целочисленный тип, c - char.</p>
<p><span class="page_code_style">S.insert(i, T)</span> - вставить содержимое строки T. T может быть объектом класса string или C-строкой.</p>
<p><span class="page_code_style">S.insert(i, T, pos, count)</span> - вставить символы строки T начиная с символа с индексом pos количеством count.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:insert" href="http://www.cppreference.com/wiki/ru/string/insert">insert</a>.</p>
<h3>substr</h3>
<p><span class="page_code_style">S.substr(pos)</span> - возвращает подстроку данной строки начиная с символа с индексом pos и до конца строки.</p>
<p><span class="page_code_style">S.substr(pos, count)</span> - возвращает подстроку данной строки начиная с символа с индексом pos количеством count или до конца строки, если pos + count &gt; S.size().</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:substr" href="http://www.cppreference.com/wiki/ru/string/substr">substr</a>.</p>
<h3>replace</h3>
<p>Заменяет фрагмент строки на несколько равных символов, другую строку или фрагмент другой строки. Способы вызова аналогичны способам вызова метода append, только первыми двумя параметрами являются два числа: pos и count. Из данной строки удаляется count символов, начиная с символа pos, и на их место вставляются новые символы.</p>
<p><span class="page_code_style">S.replace(pos, count, n, c)</span> - вставить n одинаковых символов, равных с. n имеет целочисленный тип, c - char.</p>
<p><span class="page_code_style">S.replace(pos, count, T)</span> - вставить содержимое строки T. T может быть объектом класса string или C-строкой.</p>
<p><span class="page_code_style">S.replace(pos, count, T, pos2, count2)</span> - вставить символы строки T начиная с символа с индексом pos количеством count.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:replace" href="http://www.cppreference.com/wiki/ru/string/replace">replace</a>.</p>
<h3>find</h3>
<p>Ищет в данной строке первое вхождение другой строки str. Возвращается номер первого символа, начиная с которого далее идет подстрока, равная строке str. Если эта строка не найдена, то возвращается константа string::npos (которая равна -1, но при этом является беззнаковой, то есть на самом деле является большим безннаковым положительным числом).</p>
<p>Если задано значение pos, то поиск начинается с позиции pos, то есть возращаемое значение будет не меньше, чем pos. Если значение pos не указано, то считается, что оно равно 0 - поиск осуществляется с начала строки.</p>
<p><span class="page_code_style">S.find(str, pos = 0)</span> - искать первое входение строки str начиная с позиции pos. Если pos не задано - то начиная с начала строки S.</p>
<p><span class="page_code_style">S.find(str, pos, n)</span> - искать в данной строке подстроку, равную первым n символам строки str. Значение pos должно быть задано.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:find" href="http://www.cppreference.com/wiki/ru/string/find">find</a>.</p>
<h3>rfind</h3>
<p>Ищет последнее вхождение подстроки ("правый" поиск). Способы вызова аналогичны способам вызова метода find.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:rfind" href="http://www.cppreference.com/wiki/ru/string/rfind">rfind</a>.</p>
<h3>find_first_of</h3>
<p>Ищет в данной строке первое появление любого из символов данной строки str. Возвращается номер этого символа или значение string::npos.</p>
<p>Если задано значение pos, то поиск начинается с позиции pos, то есть возращаемое значение будет не меньше, чем pos. Если значение pos не указано, то считается, что оно равно 0 - поиск осуществляется с начала строки.</p>
<p><span class="page_code_style">S.find_first_of(str, pos = 0)</span> - искать первое входение любого символа строки str начиная с позиции pos. Если pos не задано - то начиная с начала строки S.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:find_first_of" href="http://www.cppreference.com/wiki/ru/string/find_first_of">find_first_of</a>.</p>
<h3>find_last_of</h3>
<p>Ищет в данной строке последнее появление любого из символов данной строки str. Способы вызова и возвращаемое значение аналогичны методу find_first_of.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:find_last_of" href="http://www.cppreference.com/wiki/ru/string/find_last_of">find_last_of</a>.</p>
<h3>find_first_not_of</h3>
<p>Ищет в данной строке первое появление символа, отличного от символов строки str. Способы вызова и возвращаемое значение аналогичны методу find_first_of.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:find_first_not_of" href="http://www.cppreference.com/wiki/ru/string/find_first_not_of">find_first_not_of</a>.</p>
<h3>find_last_not_of</h3>
<p>Ищет в данной строке последнее появление символа, отличного от символов строки str. Способы вызова и возвращаемое значение аналогичны методу find_first_of.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:find_last_not_of" href="http://www.cppreference.com/wiki/ru/string/find_last_not_of">find_last_not_of</a>.</p>
<h3>c_str</h3>
<p>Возвращает указать на область памяти, в которой хранятся символы строки, возвращает значение типа char*. Возвращаемое значение можно рассматривать как C-строку и использовать в функциях, которые должны получать на вход C-строку.</p>
<p>Подробней о методе <a class="wikilink1" title="ru:string:c_str" href="http://www.cppreference.com/wiki/ru/string/c_str">c_str</a>.</p>





<svg id="MJX-SVG-global-cache" style="display: none;"><defs></defs></svg></body></html>